//cam code is same as before

//TX:
// TX (ESP32-WROOM) - receives file via TCP, sends over Reyax LoRa in chunks
#include <WiFi.h>
#include "FS.h"
#include "SPIFFS.h"

const char* ssid = "Airtel";
const char* password = "saherali";
const uint16_t listen_port = 12345;

WiFiServer tcpServer(listen_port);

// --- Reyax config ---
HardwareSerial &reyax = Serial2;
const unsigned long REYAX_BAUD = 115200;
const uint16_t REYAX_TX_ADDR = 7;   // TX side address (this module)
const uint16_t REYAX_DST_ADDR = 12; // RX address (remote)
const size_t CHUNK_RAW = 10;       // raw bytes per chunk (keeps it identical to your code)
const unsigned long ACK_TIMEOUT_MS = 8000UL; // per chunk
const uint8_t MAX_RETRIES = 5;

void flushReyaxInput() { while (reyax.available()) reyax.read(); }

bool sendATCommand(const String &cmd, unsigned long timeout=1000) {
  while (reyax.available()) reyax.read();
  reyax.print(cmd); reyax.print("\r\n");
  unsigned long t0 = millis();
  String resp = "";
  while (millis()-t0 < timeout) {
    while (reyax.available()) {
      char c=(char)reyax.read();
      resp += c;
      if (resp.endsWith("\r\nOK\r\n")) return true;
      if (resp.indexOf("ERROR")>=0) return false;
    }
  }
  return false;
}

String toHex(const uint8_t *data, size_t len) {
  static const char hexchars[]="0123456789ABCDEF";
  String s; s.reserve(len*2+4);
  for(size_t i=0;i<len;i++){uint8_t b=data[i]; s+=hexchars[b>>4]; s+=hexchars[b&0x0F];}
  return s;
}

// Wait for ACK:<seq> from Reyax (as string on serial)
bool waitForACK(uint16_t seq, unsigned long timeoutMs) {
  unsigned long t0=millis(); String incoming="";
  while(millis()-t0<timeoutMs){
    while(reyax.available()){
      char c=(char)reyax.read();
      incoming += c;
      if (incoming.endsWith("\r\n")) {
        if (incoming.indexOf("ACK:") >= 0) {
          int p = incoming.indexOf("ACK:");
          String seqStr = incoming.substring(p+4);
          seqStr.trim();
          long rseq = seqStr.toInt();
          incoming = "";
          if (rseq == seq) return true;
        } else {
          incoming = "";
        }
      }
    }
    delay(5);
  }
  return false;
}

void setupReyax() {
  // Serial2 uses pins TX=5, RX=4 on this TX sketch (as in your previous TX)
  reyax.begin(REYAX_BAUD, SERIAL_8N1, 4, 5);
  delay(100);
  sendATCommand(String("AT+ADDRESS=") + REYAX_TX_ADDR, 1500);
  flushReyaxInput();
}

void setup() {
  Serial.begin(115200);
  delay(100);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");

  unsigned long startAttemptTime = millis();
  const unsigned long wifiTimeout = 15000; // 15 seconds timeout

  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < wifiTimeout) {
    delay(300);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("\nConnected. IP: %s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("\nWiFi connection failed. Check credentials.");
    // This matches your earlier behavior — halt if WiFi failed
    while (true) delay(1000);
  }

  if(!SPIFFS.begin(true)){
    Serial.println("SPIFFS not mounted");
    while(1) delay(1000);
  }

  setupReyax();
  tcpServer.begin();
  Serial.println("\nTX ready - waiting for TCP upload...");
}

// Helper: send raw ASCII payload via AT+SEND and wait a short time for Reyax response
void sendLoRaPacketASCII(const String &payload) {
  String cmd = "AT+SEND=" + String(REYAX_DST_ADDR) + "," + String(payload.length()) + "," + payload;
  reyax.print(cmd); reyax.print("\r\n");
  // read and echo any immediate output for debugging
  unsigned long t0 = millis();
  while (millis() - t0 < 300) {
    while (reyax.available()) Serial.write((char)reyax.read());
  }
}

// Send file from SPIFFS via chunked protocol with ACKs
void sendFileOverLoRa(const char *path) {
  File f = SPIFFS.open(path, FILE_READ);
  if (!f) {
    Serial.println("Failed to open file");
    return;
  }
  size_t total = f.size();
  Serial.printf("Sending file size: %u bytes\n", (unsigned) total);
  sendLoRaPacketASCII("HDR:" + String(total));
  delay(500);

  uint8_t buf[CHUNK_RAW];
  uint16_t seq = 0;
  size_t sentBytes = 0;
  while (sentBytes < total) {
    size_t toRead = min((size_t)CHUNK_RAW, total - sentBytes);
    size_t r = f.read(buf, toRead);
    if (r == 0) break;
    String hexstr = toHex(buf, r);
    char seqStr[8];
    sprintf(seqStr, "%04u", seq);
    String packet = "H:" + String(seqStr) + ":" + hexstr;

    bool acked = false;
    for (uint8_t attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      sendLoRaPacketASCII(packet);
      Serial.printf("Sent image packet seq=%u (attempt %u)\n", seq, attempt);
      if (waitForACK(seq, ACK_TIMEOUT_MS)) {
        acked = true;
        break;
      }
      Serial.printf("Retry %d for seq %u\n", attempt, seq);
      delay(200);
    }
    if (!acked) {
      Serial.printf("Chunk %u failed after %d retries. Abort.\n", seq, MAX_RETRIES);
      f.close();
      return;
    }
    sentBytes += r;
    seq++;
    delay(30);
  }
  sendLoRaPacketASCII("END");
  Serial.println("Sent END");
  f.close();
}

void loop() {
  // Accept incoming TCP upload (from ESP32-CAM)
  WiFiClient client = tcpServer.available();
  if (client) {
    Serial.println("TCP client connected — receiving file...");
    // Save TCP stream to SPIFFS /to_send.jpg
    File file = SPIFFS.open("/to_send.jpg", FILE_WRITE);
    if (!file) {
      Serial.println("Failed to open /to_send.jpg for writing");
      client.stop();
      return;
    }
    uint8_t buffer[1024];
    size_t totalBytes = 0;
    unsigned long lastRecv = millis();
    while (client.connected()) {
      while (client.available()) {
        size_t br = client.read(buffer, sizeof(buffer));
        if (br > 0) {
          file.write(buffer, br);
          totalBytes += br;
          lastRecv = millis();
        }
      }
      // If transfer stalls for 2 seconds, assume done
      if (millis() - lastRecv > 2000) break;
      delay(10);
    }
    file.close();
    client.stop();
    Serial.printf("TCP received %u bytes\n", (unsigned)totalBytes);

    // Now transmit received file over LoRa
    sendFileOverLoRa("/to_send.jpg");
    Serial.println("Finished LoRa transmission.");
  }

  // Keep reading Reyax debug output periodically
  while (reyax.available()) Serial.write((char)reyax.read());
  delay(10);
}




//RX
// RX (DevKit) - receive chunked image via Reyax LoRa and save to SD (then display on TFT)
#include <HardwareSerial.h>
#include <SPI.h>
#include <SD.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <JPEGDecoder.h>

// Reyax on Serial2
HardwareSerial &reyax = Serial2;
const unsigned long REYAX_BAUD = 115200;
const uint8_t REYAX_ADDR = 12;    // this RX module's Reyax address
const uint8_t REYAX_TX_ADDR = 7;  // remote (TX) Reyax address to reply ACKs
const int REYAX_RX_PIN = 16;      // Reyax TX -> ESP RX
const int REYAX_TX_PIN = 17;      // Reyax RX <- ESP TX

// TFT + SD pins (your provided wiring)
#define TFT_CS   5
#define TFT_DC   2
#define TFT_RST  4
#define SD_CS    14   // SD card chip select (as you specified)

Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);

// Receiving state
bool receiving = false;
uint32_t expectedSize = 0;
uint32_t receivedBytes = 0;
String partialLine = "";

// Path on SD where we will save
const char *SD_IMG_PATH = "/IM.JPG";

// CHUNK size must match TX (raw bytes per H: packet)
const size_t CHUNK_RAW = 10;

// --- Helpers ---
void setupReyax() {
  // use Serial2 with pins RX=16, TX=17
  reyax.begin(REYAX_BAUD, SERIAL_8N1, REYAX_RX_PIN, REYAX_TX_PIN);
  delay(150);
  Serial.println("Setting Reyax address (RX side)...");
  reyax.print(String("AT+ADDRESS=") + REYAX_ADDR + "\r\n");
  delay(300);

  unsigned long t0 = millis();
  while (millis() - t0 < 500) {
    while (reyax.available()) {
      String s = reyax.readStringUntil('\n');
      s.trim();
      if (s.length()) Serial.print("REYAX INIT: "), Serial.println(s);
    }
  }
}

// send ack back via Reyax AT+SEND
void sendLoRaASCII(const String &payload) {
  String cmd = "AT+SEND=" + String(REYAX_TX_ADDR) + "," + String(payload.length()) + "," + payload;
  Serial.printf(">> REYAX SEND: %s\n", cmd.c_str());
  reyax.print(cmd + "\r\n");
  unsigned long t0 = millis();
  while (millis() - t0 < 300) {
    while (reyax.available()) {
      char c = (char)reyax.read();
      Serial.write(c);
    }
  }
}

// Convert hex string to bytes in-place into buffer (buffer must be large enough)
size_t hexToBytesToSD(const String &hex, File &f) {
  size_t L = hex.length();
  if (L % 2 != 0) {
    Serial.println("hexToBytesToSD: odd len");
    return 0;
  }
  size_t outLen = 0;
  for (size_t i = 0; i < L; i += 2) {
    char a = hex.charAt(i);
    char b = hex.charAt(i + 1);
    char tmp[3] = { a, b, 0 };
    uint8_t val = (uint8_t) strtol(tmp, NULL, 16);
    f.write(val);
    outLen++;
  }
  return outLen;
}

// Draw receiving progress on TFT
void drawReceivingScreen() {
  tft.fillScreen(ILI9341_PINK);
  tft.setCursor(10, 20);
  tft.setTextSize(2);
  tft.setTextColor(ILI9341_BLACK);
  tft.println("Receiving image...");
  tft.setTextSize(1);
  tft.setCursor(10, 60);
  tft.print("Expected: ");
  tft.print(expectedSize);
  tft.println(" bytes");
  tft.setCursor(10, 80);
  tft.print("Received: ");
  tft.print(receivedBytes);
  tft.println(" bytes");
  uint32_t chunks = (expectedSize + CHUNK_RAW - 1) / CHUNK_RAW;
  tft.setCursor(10, 100);
  tft.print("Chunks total: ");
  tft.println(chunks);
  tft.setCursor(10, 120);
  tft.print("Progress: ");
  if (expectedSize > 0) {
    int pct = (int)((receivedBytes * 100) / expectedSize);
    tft.print(pct);
    tft.println("%");
  } else {
    tft.println("0%");
  }
}

// After file saved to SD, decode and render it
void renderSavedJpeg() {
  tft.fillScreen(ILI9341_BLACK);
  tft.setCursor(10, 10);
  tft.setTextColor(ILI9341_CYAN);
  tft.setTextSize(2);
  tft.println("Rendering image...");
  delay(200);

  File jpegFile = SD.open(SD_IMG_PATH, FILE_READ);
  if (!jpegFile) {
    Serial.println("Saved file not found on SD!");
    tft.setCursor(10, 40);
    tft.println("No IMG on SD");
    return;
  }

  if (JpegDec.decodeSdFile(jpegFile)) {
    // zoom/draw code from your snippet
    uint16_t imgW = JpegDec.width;
    uint16_t imgH = JpegDec.height;
    float scaleX = (float)tft.width() / imgW;
    float scaleY = (float)tft.height() / imgH;
    uint32_t drawTime = millis();

    while (JpegDec.read()) {
      uint16_t *pImg = JpegDec.pImage;
      uint16_t mcuW = JpegDec.MCUWidth;
      uint16_t mcuH = JpegDec.MCUHeight;
      for (int y = 0; y < mcuH; y++) {
        for (int x = 0; x < mcuW; x++) {
          int imgX = JpegDec.MCUx * mcuW + x;
          int imgY = JpegDec.MCUy * mcuH + y;
          if (imgX >= imgW || imgY >= imgH) continue;
          uint16_t color = pImg[y * mcuW + x];
          int screenX = imgX * scaleX;
          int screenY = imgY * scaleY;
          tft.fillRect(screenX, screenY, scaleX + 1, scaleY + 1, color);
        }
      }
    }
    Serial.print("JPEG drawn in ");
    Serial.print(millis() - drawTime);
    Serial.println(" ms");
  } else {
    Serial.println("JPEG decode failed!");
    tft.setCursor(10, 40);
    tft.setTextColor(ILI9341_RED);
    tft.println("Decode failed!");
  }
  jpegFile.close();
}

// Parse +RCV lines and handle HDR/H:/END payloads (payload is between the 3rd and 4th comma)
void handleReyaxLine(const String &lineIn) {
  String line = lineIn;
  line.trim();
  if (line.length() == 0) return;
  Serial.printf("REYAX LINE: %s\n", line.c_str());

  int eqPos = line.indexOf('=');
  if (eqPos < 0) return;

  int c1 = line.indexOf(',', eqPos + 1);
  int c2 = line.indexOf(',', c1 + 1);
  int c3 = line.indexOf(',', c2 + 1);
  // Some Reyax firmware variants might send fewer trailing commas; be defensive:
  if (c1 < 0 || c2 < 0) return;

  // payload may go until c3 (if present) or to end of line
  String payload;
  if (c3 >= 0) payload = line.substring(c2 + 1, c3);
  else payload = line.substring(c2 + 1);
  payload.trim();

  if (payload.length() == 0) return;

  // HDR:
  if (payload.startsWith("HDR:")) {
    expectedSize = (uint32_t) payload.substring(4).toInt();
    Serial.printf("HDR received. Expecting %u bytes. Creating SD file...\n", expectedSize);
    // remove existing file
    if (SD.exists(SD_IMG_PATH)) SD.remove(SD_IMG_PATH);
    File f = SD.open(SD_IMG_PATH, FILE_WRITE);
    if (!f) {
      Serial.println("Failed to open SD image for writing!");
      receiving = false;
      return;
    }
    f.close();
    receiving = true;
    receivedBytes = 0;
    // draw initial receiving screen
    drawReceivingScreen();
  }
  // END
  else if (payload == "END") {
    Serial.println("END received. Closing SD file.");
    receiving = false;
    // ensure file closed and flush (we write per chunk so file will be closed)
    Serial.printf("Total written: %u bytes. File saved to %s\n", receivedBytes, SD_IMG_PATH);
    // update TFT
    tft.fillScreen(ILI9341_GREEN);
    tft.setCursor(10, 10);
    tft.setTextSize(2);
    tft.setTextColor(ILI9341_BLACK);
    tft.println("Image Received!");
    delay(400);
    renderSavedJpeg();
  }
  // H: packet with seq and hexdata
  else if (payload.startsWith("H:")) {
    int secondColon = payload.indexOf(':', 2);
    if (secondColon < 0) return;
    String seqStr = payload.substring(2, secondColon);
    String hexdata = payload.substring(secondColon + 1);
    uint16_t seq = (uint16_t) seqStr.toInt();

    if (hexdata.length() > 0 && receiving) {
      File f = SD.open(SD_IMG_PATH, FILE_APPEND);
      if (!f) {
        Serial.println("Failed to open SD append!");
        return;
      }
      size_t outLen = hexToBytesToSD(hexdata, f);
      f.flush();
      f.close();
      receivedBytes += outLen;
      Serial.printf("Wrote seq %u bytes=%u total=%u\n", seq, (unsigned)outLen, (unsigned)receivedBytes);
      // update TFT progress
      drawReceivingScreen();
    }
    // send ACK back
    String ack = String("ACK:") + String(seq);
    sendLoRaASCII(ack);
    Serial.printf("ACK sent for seq %u\n", seq);
  }
  // else: payload might be sensor data or "Hi" beacons; ignore or log
  else {
    Serial.printf("Other payload: %s\n", payload.c_str());
  }
}

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println("\nRX (TFT) starting...");

  // TFT init
  tft.begin();
  tft.setRotation(1);
  tft.fillScreen(ILI9341_BLACK);
  tft.setTextColor(ILI9341_CYAN);
  tft.setTextSize(2);
  tft.setCursor(10, 10);
  tft.println("RX System Booting...");

  // SD init
  if (!SD.begin(SD_CS)) {
    Serial.println("SD card init failed!");
    tft.setCursor(10, 40);
    tft.setTextColor(ILI9341_RED);
    tft.setTextSize(2);
    tft.println("SD init failed!");
    while (1) delay(1000);
  } else {
    Serial.println("SD initialized.");
  }

  // Reyax
  setupReyax();

  // ready screen
  tft.fillScreen(ILI9341_BLACK);
  tft.setCursor(10, 10);
  tft.setTextColor(ILI9341_CYAN);
  tft.setTextSize(2);
  tft.println("RX Ready - Waiting for LoRa");
}

void loop() {
  // Read Reyax incoming bytes and build lines (line terminated by '\n')
  while (reyax.available()) {
    char c = (char) reyax.read();
    Serial.write(c); // echo to Serial debug
    if (c == '\n') {
      String line = partialLine;
      line.trim();
      if (line.length() > 0) handleReyaxLine(line);
      partialLine = "";
    } else if (c != '\r') {
      partialLine += c;
      if (partialLine.length() > 1200) partialLine = ""; // safety
    }
  }

  delay(5);
}
